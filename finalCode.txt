/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Smart Apartment Energy Monitor (Option A)
  *
  * Features:
  *  - STM32 Nucleo-F411RE
  *  - 2x INA219 current/voltage sensors
  *  - SSD1306 0.96" OLED via I2C
  *  - ESP-01S as Wi-Fi Access Point (SoftAP)
  *  - Simple cooperative scheduler (RTOS-like)
  *  - Power smoothing + energy integration (Wh)
  *
  * ESP-01S:
  *  - Starts AP:  SSID = EnergyMonitor_AP
  *  - Password:   password123
  *  - Your phone can join that Wi-Fi network (no internet required).
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include <string.h>
#include <stdio.h>
#include <math.h>

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* Simple task struct for our cooperative scheduler */
typedef struct {
  uint32_t period_ms;
  uint32_t next_run_ms;
} Task_t;

/* INA219 channel data */
typedef struct {
  float v_V;       // latest voltage
  float i_A;       // latest current
  float p_W;       // latest power
  float p_W_filt;  // filtered power
  float E_Wh;      // accumulated energy
} ChannelData_t;

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* INA219 I2C addresses (7-bit, left-shifted for HAL) */
#define INA219_ADDR1     (0x40 << 1)
#define INA219_ADDR2     (0x41 << 1)

/* INA219 Registers */
#define INA219_REG_CONFIG       0x00
#define INA219_REG_SHUNT_V      0x01
#define INA219_REG_BUS_V        0x02
#define INA219_REG_POWER        0x03
#define INA219_REG_CURRENT      0x04
#define INA219_REG_CALIBRATION  0x05

/* Calibration values:
 * Assumes 0.1 Ohm shunt resistor on the INA219 board.
 * Current_LSB = 100 µA, Power_LSB = 2 mW (approx).
 */
static uint16_t INA219_CalibrationValue = 4096;
static float INA219_Current_LSB = 0.0001f;  // 100 µA/LSB
static float INA219_Power_LSB   = 0.002f;   // 2 mW/LSB

/* OLED parameters (SSD1306) */
#define OLED_ADDR   (0x3C << 1)
#define OLED_WIDTH  128
#define OLED_HEIGHT 64
#define OLED_PAGES  (OLED_HEIGHT / 8)

/* Smoothing factor for exponential moving average (0..1) */
static const float alpha = 0.2f;

/* SoftAP settings for ESP-01S */
#define ESP_AP_SSID     "EnergyMonitor_AP"
#define ESP_AP_PASSWORD "password123"
#define ESP_AP_CHANNEL  5   // Wi-Fi channel
#define ESP_AP_ENC      3   // WPA2_PSK (for AT+CWSAP)

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */

/* Global channel data for two INA219 devices */
ChannelData_t ch1 = {0}, ch2 = {0};

/* Cooperative tasks:
 *  - Sample INA219 every 100 ms
 *  - Update OLED every 200 ms
 *  - Status task every 1000 ms (heartbeat / debug print)
 */
Task_t taskSampleINA   = { .period_ms = 100,  .next_run_ms = 0 };
Task_t taskUpdateOLED  = { .period_ms = 200,  .next_run_ms = 0 };
Task_t taskStatus      = { .period_ms = 1000, .next_run_ms = 0 };

/* OLED framebuffer */
static uint8_t oled_buffer[OLED_WIDTH * OLED_PAGES];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART2_UART_Init(void);
/* USER CODE BEGIN PFP */

/* Debug UART */
void debug_print(const char *s);
void debug_println(const char *s);

/* I2C Scanner (optional debug) */
void I2C_Scan(void);

/* INA219 helpers */
HAL_StatusTypeDef INA_WriteReg(uint16_t addr, uint8_t reg, uint16_t val);
HAL_StatusTypeDef INA_ReadReg(uint16_t addr, uint8_t reg, uint16_t *val);
void INA_Init(uint16_t addr);
void INA_Read(uint16_t addr, float *voltage, float *current, float *power);

/* OLED helpers */
void OLED_Cmd(uint8_t cmd);
void OLED_Init(void);
void OLED_ClearBuffer(void);
void OLED_Update(void);
void OLED_DrawChar(uint8_t x, uint8_t y, char c);
void OLED_DrawString(uint8_t x, uint8_t y, const char *s);

/* ESP-01S helpers (Access Point only) */
void ESP_SendRaw(const char *s);
void ESP_StartAccessPoint(void);

/* Tasks */
void Task_SampleINA(uint32_t dt_ms);
void Task_UpdateOLED(void);
void Task_Status(void);

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* === Debug UART === */
void debug_print(const char *s) {
  HAL_UART_Transmit(&huart2, (uint8_t*)s, strlen(s), HAL_MAX_DELAY);
}
void debug_println(const char *s) {
  debug_print(s);
  debug_print("\r\n");
}

/* === I2C Scanner (optional) === */
void I2C_Scan(void) {
  debug_println("Scanning I2C bus...");
  char msg[64];

  for (uint8_t addr = 1; addr < 127; addr++) {
    if (HAL_I2C_IsDeviceReady(&hi2c1, addr << 1, 1, 10) == HAL_OK) {
      snprintf(msg, sizeof(msg), " - Found device at 0x%02X", addr);
      debug_println(msg);
    }
  }
  debug_println("I2C scan complete.\r\n");
}

/* === INA219 === */
HAL_StatusTypeDef INA_WriteReg(uint16_t addr, uint8_t reg, uint16_t val) {
  uint8_t data[3] = { reg, (uint8_t)(val >> 8), (uint8_t)(val & 0xFF) };
  return HAL_I2C_Master_Transmit(&hi2c1, addr, data, 3, HAL_MAX_DELAY);
}

HAL_StatusTypeDef INA_ReadReg(uint16_t addr, uint8_t reg, uint16_t *val) {
  uint8_t buf[2];
  HAL_StatusTypeDef res;

  res = HAL_I2C_Master_Transmit(&hi2c1, addr, &reg, 1, HAL_MAX_DELAY);
  if (res != HAL_OK) return res;

  res = HAL_I2C_Master_Receive(&hi2c1, addr, buf, 2, HAL_MAX_DELAY);
  if (res != HAL_OK) return res;

  *val = (buf[0] << 8) | buf[1];
  return HAL_OK;
}

void INA_Init(uint16_t addr) {
  /* Calibration */
  INA_WriteReg(addr, INA219_REG_CALIBRATION, INA219_CalibrationValue);

  /* Config: 32V range, 320mV shunt, 12-bit bus+shunt, continuous mode */
  uint16_t config = 0;
  config |= (1 << 13);   // BRNG = 1 (32V)
  config |= (3 << 11);   // PG   = 3 (320mV)
  config |= (3 << 7);    // BADC = 3 (12-bit)
  config |= (3 << 3);    // SADC = 3 (12-bit)
  config |= 7;           // Mode = shunt + bus, continuous

  INA_WriteReg(addr, INA219_REG_CONFIG, config);
}

void INA_Read(uint16_t addr, float *voltage, float *current, float *power) {
  uint16_t raw;
  int16_t sraw;

  /* Bus voltage */
  INA_ReadReg(addr, INA219_REG_BUS_V, &raw);
  *voltage = ((raw >> 3) * 0.004f); // 4mV/bit, bits 0-2 are flags

  /* Current */
  INA_ReadReg(addr, INA219_REG_CURRENT, &raw);
  sraw = (int16_t)raw;
  *current = (float)sraw * INA219_Current_LSB;

  /* Power */
  INA_ReadReg(addr, INA219_REG_POWER, &raw);
  *power = (float)raw * INA219_Power_LSB;
}

/* === Minimal 5x7 glyph generator for digits + a few letters === */
/* We only support characters we actually use: digits, '.', 'C','H','T','o','t','W','h',':',' ' */
static void getGlyph5x7(char c, uint8_t out[5]) {
  memset(out, 0x00, 5);

  switch (c) {
    case '0': { uint8_t g[5] = {0x3E,0x51,0x49,0x45,0x3E}; memcpy(out,g,5); break; }
    case '1': { uint8_t g[5] = {0x00,0x42,0x7F,0x40,0x00}; memcpy(out,g,5); break; }
    case '2': { uint8_t g[5] = {0x42,0x61,0x51,0x49,0x46}; memcpy(out,g,5); break; }
    case '3': { uint8_t g[5] = {0x21,0x41,0x45,0x4B,0x31}; memcpy(out,g,5); break; }
    case '4': { uint8_t g[5] = {0x18,0x14,0x12,0x7F,0x10}; memcpy(out,g,5); break; }
    case '5': { uint8_t g[5] = {0x27,0x45,0x45,0x45,0x39}; memcpy(out,g,5); break; }
    case '6': { uint8_t g[5] = {0x3C,0x4A,0x49,0x49,0x30}; memcpy(out,g,5); break; }
    case '7': { uint8_t g[5] = {0x01,0x71,0x09,0x05,0x03}; memcpy(out,g,5); break; }
    case '8': { uint8_t g[5] = {0x36,0x49,0x49,0x49,0x36}; memcpy(out,g,5); break; }
    case '9': { uint8_t g[5] = {0x06,0x49,0x49,0x29,0x1E}; memcpy(out,g,5); break; }
    case '.': { uint8_t g[5] = {0x00,0x60,0x60,0x00,0x00}; memcpy(out,g,5); break; }
    case 'C': { uint8_t g[5] = {0x3C,0x42,0x41,0x41,0x22}; memcpy(out,g,5); break; }
    case 'H': { uint8_t g[5] = {0x7F,0x08,0x08,0x08,0x7F}; memcpy(out,g,5); break; }
    case 'T': { uint8_t g[5] = {0x01,0x01,0x7F,0x01,0x01}; memcpy(out,g,5); break; }
    case 'o': { uint8_t g[5] = {0x38,0x44,0x44,0x44,0x38}; memcpy(out,g,5); break; }
    case 't': { uint8_t g[5] = {0x04,0x3F,0x44,0x40,0x20}; memcpy(out,g,5); break; }
    case 'W': { uint8_t g[5] = {0x7E,0x20,0x18,0x20,0x7E}; memcpy(out,g,5); break; }
    case 'h': { uint8_t g[5] = {0x7F,0x08,0x04,0x04,0x78}; memcpy(out,g,5); break; }
    case ':': { uint8_t g[5] = {0x00,0x36,0x36,0x00,0x00}; memcpy(out,g,5); break; }
    case ' ': default: { uint8_t g[5] = {0x00,0x00,0x00,0x00,0x00}; memcpy(out,g,5); break; }
  }
}

/* === OLED === */
void OLED_Cmd(uint8_t cmd) {
  uint8_t data[2] = {0x00, cmd};
  HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDR, data, 2, HAL_MAX_DELAY);
}

void OLED_Init(void) {
  HAL_Delay(100);
  OLED_Cmd(0xAE);
  OLED_Cmd(0x20); OLED_Cmd(0x00); // horizontal mode
  OLED_Cmd(0xB0);
  OLED_Cmd(0xC8);
  OLED_Cmd(0x00);
  OLED_Cmd(0x10);
  OLED_Cmd(0x40);
  OLED_Cmd(0x81); OLED_Cmd(0x7F);
  OLED_Cmd(0xA1);
  OLED_Cmd(0xA6);
  OLED_Cmd(0xA8); OLED_Cmd(0x3F);
  OLED_Cmd(0xA4);
  OLED_Cmd(0xD3); OLED_Cmd(0x00);
  OLED_Cmd(0xD5); OLED_Cmd(0x80);
  OLED_Cmd(0xD9); OLED_Cmd(0xF1);
  OLED_Cmd(0xDA); OLED_Cmd(0x12);
  OLED_Cmd(0xDB); OLED_Cmd(0x40);
  OLED_Cmd(0x8D); OLED_Cmd(0x14);
  OLED_Cmd(0xAF);
}

void OLED_ClearBuffer(void) {
  memset(oled_buffer, 0x00, sizeof(oled_buffer));
}

void OLED_Update(void) {
  for (uint8_t page = 0; page < OLED_PAGES; page++) {
    OLED_Cmd(0xB0 + page);
    OLED_Cmd(0x00);
    OLED_Cmd(0x10);
    uint8_t control = 0x40;
    HAL_I2C_Mem_Write(&hi2c1, OLED_ADDR, control, 1,
                      &oled_buffer[OLED_WIDTH * page],
                      OLED_WIDTH,
                      HAL_MAX_DELAY);
  }
}

/* Draw a char at pixel (x,y) */
void OLED_DrawChar(uint8_t x, uint8_t y, char c) {
  if (x >= OLED_WIDTH || y >= OLED_HEIGHT) return;

  uint8_t glyph[5];
  getGlyph5x7(c, glyph);

  uint8_t page = y / 8;
  uint8_t bit_in_page = y % 8;

  for (uint8_t col = 0; col < 5; col++) {
    uint8_t line = glyph[col];
    uint16_t idx = page * OLED_WIDTH + x + col;
    if (idx >= sizeof(oled_buffer)) continue;
    oled_buffer[idx] |= (line << bit_in_page);
  }
}

/* Draw a string starting at (x,y) */
void OLED_DrawString(uint8_t x, uint8_t y, const char *s) {
  while (*s && x < (OLED_WIDTH - 6)) {
    OLED_DrawChar(x, y, *s++);
    x += 6; // 5 px + 1 px space
  }
}

/* === ESP-01S: Soft Access Point === */

void ESP_SendRaw(const char *s) {
  HAL_UART_Transmit(&huart2, (uint8_t*)s, strlen(s), HAL_MAX_DELAY);
}

/* Start ESP-01S as an Access Point:
 *   SSID:     EnergyMonitor_AP
 *   Password: password123
 * After this, your phone can connect to that Wi-Fi network.
 */
void ESP_StartAccessPoint(void) {
  char cmd[128];

  debug_println("Initializing ESP-01S as Access Point...");

  /* Basic AT test */
  ESP_SendRaw("AT\r\n");
  HAL_Delay(1000);

  /* Set Wi-Fi mode to SoftAP (2) */
  ESP_SendRaw("AT+CWMODE=2\r\n");
  HAL_Delay(1000);

  /* Configure AP: AT+CWSAP="ssid","pwd",channel,enc */
  snprintf(cmd, sizeof(cmd),
           "AT+CWSAP=\"%s\",\"%s\",%d,%d\r\n",
           ESP_AP_SSID, ESP_AP_PASSWORD,
           ESP_AP_CHANNEL, ESP_AP_ENC);

  debug_print("Starting AP SSID: ");
  debug_println(ESP_AP_SSID);
  ESP_SendRaw(cmd);
  HAL_Delay(2000);

  debug_println("ESP AP ready. Connect your phone to:");
  debug_print("SSID: "); debug_println(ESP_AP_SSID);
  debug_print("PASS: "); debug_println(ESP_AP_PASSWORD);
  debug_println("");
}

/* === Tasks === */

/* 1) Sample INA219s and update smoothed power + Wh */
void Task_SampleINA(uint32_t dt_ms) {
  float v, i, p;

  /* Channel 1 */
  INA_Read(INA219_ADDR1, &v, &i, &p);
  ch1.v_V = v;
  ch1.i_A = i;
  ch1.p_W = p;
  if (ch1.p_W_filt == 0.0f) ch1.p_W_filt = p;
  else ch1.p_W_filt = alpha * p + (1.0f - alpha) * ch1.p_W_filt;
  ch1.E_Wh += ch1.p_W_filt * (dt_ms / 3600000.0f); // P(W) * t(h)

  /* Channel 2 */
  INA_Read(INA219_ADDR2, &v, &i, &p);
  ch2.v_V = v;
  ch2.i_A = i;
  ch2.p_W = p;
  if (ch2.p_W_filt == 0.0f) ch2.p_W_filt = p;
  else ch2.p_W_filt = alpha * p + (1.0f - alpha) * ch2.p_W_filt;
  ch2.E_Wh += ch2.p_W_filt * (dt_ms / 3600000.0f);

  /* Optional: debug print over UART (only when ESP is disconnected or in dev) */
  char msg[128];
  snprintf(msg, sizeof(msg),
           "CH1: %.2fV %.3fA %.3fW | CH2: %.2fV %.3fA %.3fW\r\n",
           ch1.v_V, ch1.i_A, ch1.p_W_filt,
           ch2.v_V, ch2.i_A, ch2.p_W_filt);
  debug_print(msg);
}

/* 2) Update OLED with Watts & Wh */
void Task_UpdateOLED(void) {
  char line[32];

  OLED_ClearBuffer();

  snprintf(line, sizeof(line), "CH1: %4.2fW %4.2fWh", ch1.p_W_filt, ch1.E_Wh);
  OLED_DrawString(0, 0, line);

  snprintf(line, sizeof(line), "CH2: %4.2fW %4.2fWh", ch2.p_W_filt, ch2.E_Wh);
  OLED_DrawString(0, 16, line);

  float totalW  = ch1.p_W_filt + ch2.p_W_filt;
  float totalWh = ch1.E_Wh + ch2.E_Wh;

  snprintf(line, sizeof(line), "Tot: %4.2fW %4.2fWh", totalW, totalWh);
  OLED_DrawString(0, 32, line);

  OLED_Update();
}

/* 3) Status task: heartbeat / debug (1 Hz) */
void Task_Status(void) {
  static uint32_t counter = 0;
  char msg[64];
  snprintf(msg, sizeof(msg), "Status tick: %lu\r\n", (unsigned long)counter++);
  debug_print(msg);
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
  SystemClock_Config();

  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_USART2_UART_Init();

  /* USER CODE BEGIN 2 */
  debug_println("Smart Apartment Energy Monitor (Option A) Boot");

  /* Optional: scan I2C bus for devices */
  I2C_Scan();

  /* Initialize sensors and OLED */
  INA_Init(INA219_ADDR1);
  INA_Init(INA219_ADDR2);

  OLED_Init();
  OLED_ClearBuffer();
  OLED_Update();

  /* Initialize ESP in AP mode */
  ESP_StartAccessPoint();

  /* Initialize task timers */
  uint32_t now = HAL_GetTick();
  taskSampleINA.next_run_ms  = now + taskSampleINA.period_ms;
  taskUpdateOLED.next_run_ms = now + taskUpdateOLED.period_ms;
  taskStatus.next_run_ms     = now + taskStatus.period_ms;

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    uint32_t t = HAL_GetTick();

    /* Task 1: Sample INA219s (sensing) */
    if ((int32_t)(t - taskSampleINA.next_run_ms) >= 0) {
      Task_SampleINA(taskSampleINA.period_ms);
      taskSampleINA.next_run_ms += taskSampleINA.period_ms;
    }

    /* Task 2: Update OLED (UI) */
    if ((int32_t)(t - taskUpdateOLED.next_run_ms) >= 0) {
      Task_UpdateOLED();
      taskUpdateOLED.next_run_ms += taskUpdateOLED.period_ms;
    }

    /* Task 3: Status/heartbeat (communication/logging concept) */
    if ((int32_t)(t - taskStatus.next_run_ms) >= 0) {
      Task_Status();
      taskStatus.next_run_ms += taskStatus.period_ms;
    }

    HAL_Delay(1); // small idle to avoid 100% CPU
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/* ====== Standard CubeMX-generated stuff below (clock, I2C, UART, GPIO) ===== */

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK |
                                RCC_CLOCKTYPE_SYSCLK |
                                RCC_CLOCKTYPE_PCLK1 |
                                RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
    Error_Handler();
  }
}

static void MX_I2C1_Init(void)
{
  hi2c1.Instance             = I2C1;
  hi2c1.Init.ClockSpeed      = 100000;
  hi2c1.Init.DutyCycle       = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1     = 0;
  hi2c1.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2     = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
    Error_Handler();
  }
}

static void MX_USART2_UART_Init(void)
{
  huart2.Instance          = USART2;
  huart2.Init.BaudRate     = 115200;
  huart2.Init.WordLength   = UART_WORDLENGTH_8B;
  huart2.Init.StopBits     = UART_STOPBITS_1;
  huart2.Init.Parity       = UART_PARITY_NONE;
  huart2.Init.Mode         = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK) {
    Error_Handler();
  }
}

static void MX_GPIO_Init(void)
{
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) {
    // Trap here
  }
}
